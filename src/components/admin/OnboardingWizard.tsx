'use client';

import React, { useState, useRef, useEffect } from 'react';
import { ChainExtractionConfig } from '@/lib/processing/types';
import jsPDF from 'jspdf';

interface Highlight {
  id: string;
  text: string;
  startIndex: number;
  endIndex: number;
  label: string;
  labelType: 'note-type' | 'field-name' | 'end-marker' | 'other';
  noteType?: string; // Which note type this field belongs to
  fieldKey?: string; // The field key (e.g., 'behaviour_type', 'interventions')
  aiGenerated?: boolean; // Whether this was generated by AI
}

interface NoteTypeConfig {
  name: string;
  isFollowUp: boolean;
  fields: Record<string, {
    fieldName: string;
    endMarkers: string[];
  }>;
}

interface ExcelFieldMapping {
  excelColumn: string;
  confidence: number;
  reasoning: string;
  dataSource: 'EXCEL' | 'BOTH';
}

interface OnboardingConfig {
  chainId: string;
  chainName: string;
  behaviourNoteTypes: string[];
  followUpNoteTypes: string[];
  noteTypeConfigs: Record<string, NoteTypeConfig>;
  excelFieldMappings?: Record<string, ExcelFieldMapping>;
  createdAt?: string;
  updatedAt?: string;
}

export default function OnboardingWizard() {
  const [step, setStep] = useState<'upload' | 'highlight' | 'configure' | 'review' | 'saved' | 'edit-config'>('upload');
  const [pdfFile, setPdfFile] = useState<File | null>(null);
  const [excelFile, setExcelFile] = useState<File | null>(null);
  const [pdfText, setPdfText] = useState<string>('');
  const [pdfPages, setPdfPages] = useState<string[]>([]);
  const [excelData, setExcelData] = useState<{
    headers: string[];
    rows: Record<string, unknown>[];
    preview: string;
  } | null>(null);
  const [highlights, setHighlights] = useState<Highlight[]>([]);
  const [selectedText, setSelectedText] = useState<string>('');
  const [selectionStart, setSelectionStart] = useState<number>(-1);
  const [selectionEnd, setSelectionEnd] = useState<number>(-1);
  const [currentHighlight, setCurrentHighlight] = useState<Partial<Highlight> | null>(null);
  const [config, setConfig] = useState<OnboardingConfig | null>(null);
  const [chainId, setChainId] = useState<string>('');
  const [chainName, setChainName] = useState<string>('');
  const [savedConfigs, setSavedConfigs] = useState<OnboardingConfig[]>([]);
  const [loadingConfigs, setLoadingConfigs] = useState(false);
  const [viewingConfig, setViewingConfig] = useState<OnboardingConfig | null>(null);
  const [editingConfig, setEditingConfig] = useState<OnboardingConfig | null>(null);
  const [aiSuggestions, setAiSuggestions] = useState<any>(null);
  const [dataSourceMapping, setDataSourceMapping] = useState<any>(null);
  const [excelFieldMappings, setExcelFieldMappings] = useState<Record<string, ExcelFieldMapping>>({});
  const [aiLoading, setAiLoading] = useState(false);
  const [aiProgress, setAiProgress] = useState({ percent: 0, message: '' });
  const textRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    // Load saved configs on mount
    loadSavedConfigs();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handlePdfUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    if (file.type !== 'application/pdf') {
      alert('Please upload a PDF file');
      return;
    }

    setPdfFile(file);
  };

  const handleExcelUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    const isExcel = file.type === 'application/vnd.ms-excel' || 
                   file.type === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' ||
                   file.name.toLowerCase().endsWith('.xls') ||
                   file.name.toLowerCase().endsWith('.xlsx');

    if (!isExcel) {
      alert('Please upload an Excel file (.xls or .xlsx)');
      return;
    }

    setExcelFile(file);
  };

  const extractFiles = async () => {
    if (!pdfFile && !excelFile) {
      alert('Please upload at least one file (PDF or Excel)');
      return;
    }

    // Upload and extract content from both files
    const formData = new FormData();
    if (pdfFile) formData.append('pdf', pdfFile);
    if (excelFile) formData.append('excel', excelFile);

    try {
      const response = await fetch('/api/admin/extract-pdf-text', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to extract file content');
      }

      const data = await response.json();
      
      if (data.pdfText) {
        setPdfText(data.pdfText);
        setPdfPages(data.pages || []);
      }
      
      if (data.excelData) {
        setExcelData(data.excelData);
      }

      return data;
    } catch (error) {
      console.error('Error extracting files:', error);
      alert(`Failed to extract file content: ${error instanceof Error ? error.message : 'Unknown error'}`);
      throw error;
    }
  };

  const handleAnalyzeFiles = async () => {
    try {
      // First extract files if needed
      let extractedPdfText = pdfText;
      let extractedExcelData = excelData;

      if (!pdfText && !excelData) {
        const extractedData = await extractFiles();
        extractedPdfText = extractedData?.pdfText || '';
        extractedExcelData = extractedData?.excelData || null;
      }

      // Run AI analysis on both files
      setAiLoading(true);
      setAiProgress({ percent: 0, message: 'Starting analysis...' });

      // Simulate progress updates over ~45 seconds
      const startTime = Date.now();
      const totalDuration = 45000; // 45 seconds in milliseconds
      const progressSteps = [
        { time: 2000, percent: 5, message: 'Initializing analysis...' },
        { time: 5000, percent: 12, message: 'Analyzing Excel columns...' },
        { time: 10000, percent: 25, message: 'Mapping Excel fields...' },
        { time: 15000, percent: 38, message: 'Analyzing PDF structure...' },
        { time: 20000, percent: 50, message: 'Identifying note types...' },
        { time: 25000, percent: 62, message: 'Extracting field markers...' },
        { time: 30000, percent: 75, message: 'Processing field mappings...' },
        { time: 35000, percent: 85, message: 'Finalizing analysis...' },
        { time: 40000, percent: 92, message: 'Almost done...' },
      ];

      let currentStepIndex = 0;
      const progressInterval = setInterval(() => {
        const elapsed = Date.now() - startTime;
        const currentStep = progressSteps[currentStepIndex];
        
        if (currentStep && elapsed >= currentStep.time) {
          setAiProgress({ percent: currentStep.percent, message: currentStep.message });
          currentStepIndex++;
        } else if (currentStepIndex < progressSteps.length) {
          // Linear interpolation between steps
          const prevStep = currentStepIndex > 0 ? progressSteps[currentStepIndex - 1] : { time: 0, percent: 0, message: 'Starting...' };
          const nextStep = progressSteps[currentStepIndex];
          const timeDiff = nextStep.time - prevStep.time;
          const percentDiff = nextStep.percent - prevStep.percent;
          const elapsedSincePrev = elapsed - prevStep.time;
          const interpolatedPercent = Math.min(
            prevStep.percent + (elapsedSincePrev / timeDiff) * percentDiff,
            nextStep.percent
          );
          setAiProgress({ percent: Math.floor(interpolatedPercent), message: prevStep.message || 'Processing...' });
        } else if (elapsed < totalDuration) {
          // Continue from last step to 90%
          const lastStep = progressSteps[progressSteps.length - 1];
          const remainingTime = totalDuration - lastStep.time;
          const remainingPercent = 90 - lastStep.percent;
          const progressSinceLast = elapsed - lastStep.time;
          const interpolatedPercent = Math.min(
            lastStep.percent + (progressSinceLast / remainingTime) * remainingPercent,
            90
          );
          setAiProgress({ percent: Math.floor(interpolatedPercent), message: lastStep.message });
        }
      }, 500); // Update every 500ms for smooth progress

      try {
        const aiResponse = await fetch('/api/admin/analyze-pdf-config', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ 
            pdfText: extractedPdfText || pdfText || '',
            excelData: extractedExcelData || excelData || null,
          }),
        });

        clearInterval(progressInterval);
        setAiProgress({ percent: 100, message: 'Analysis complete!' });

        if (aiResponse.ok) {
          const aiData = await aiResponse.json();
          setAiSuggestions(aiData.suggestions);
          setDataSourceMapping(aiData.dataSourceMapping);
          
          // Store Excel field mappings in state
          if (aiData.suggestions?.excelFieldMappings) {
            setExcelFieldMappings(aiData.suggestions.excelFieldMappings);
          }
          
          // Auto-populate highlights from AI suggestions (only for PDF)
          const textToUse = extractedPdfText || pdfText;
          if (textToUse) {
            applyAISuggestions(aiData.suggestions, textToUse);
          }

          // Move to highlight step if we have PDF text
          if (textToUse) {
            setStep('highlight');
          }

          // Reset progress after a short delay
          setTimeout(() => {
            setAiProgress({ percent: 0, message: '' });
          }, 1000);
        } else {
          console.warn('AI analysis failed, continuing without suggestions');
          alert('AI analysis failed. Please try again.');
          setAiProgress({ percent: 0, message: '' });
        }
      } catch (aiError) {
        clearInterval(progressInterval);
        console.error('Error running AI analysis:', aiError);
        alert('Failed to analyze files. Please try again.');
        setAiProgress({ percent: 0, message: '' });
      } finally {
        setAiLoading(false);
      }
    } catch (error) {
      console.error('Error in handleAnalyzeFiles:', error);
      setAiLoading(false);
    }
  };

  const applyAISuggestions = (suggestions: any, fullText: string) => {
    const newHighlights: Highlight[] = [];

    // Add note type highlights
    if (suggestions.behaviourNoteTypes) {
      for (const noteType of suggestions.behaviourNoteTypes) {
        const index = fullText.indexOf(noteType.noteType);
        if (index !== -1) {
          newHighlights.push({
            id: `ai-note-${Date.now()}-${Math.random()}`,
            text: noteType.noteType,
            startIndex: index,
            endIndex: index + noteType.noteType.length,
            label: noteType.noteType,
            labelType: 'note-type',
            aiGenerated: true,
          });
        }
      }
    }

    if (suggestions.followUpNoteTypes) {
      for (const noteType of suggestions.followUpNoteTypes) {
        const index = fullText.indexOf(noteType.noteType);
        if (index !== -1) {
          newHighlights.push({
            id: `ai-followup-${Date.now()}-${Math.random()}`,
            text: noteType.noteType,
            startIndex: index,
            endIndex: index + noteType.noteType.length,
            label: noteType.noteType,
            labelType: 'note-type',
            aiGenerated: true,
          });
        }
      }
    }

    // Add field name highlights
    // Associate fields with the first note type found (user can reassign if needed)
    if (suggestions.fieldExtractionMarkers) {
      const firstNoteType = newHighlights.find(h => h.labelType === 'note-type')?.label || '';
      
      for (const [fieldKey, fieldData] of Object.entries(suggestions.fieldExtractionMarkers)) {
        const field = fieldData as any;
        const index = fullText.indexOf(field.fieldName);
        if (index !== -1) {
          newHighlights.push({
            id: `ai-field-${Date.now()}-${Math.random()}`,
            text: field.fieldName,
            startIndex: index,
            endIndex: index + field.fieldName.length,
            label: fieldKey,
            labelType: 'field-name',
            noteType: firstNoteType,
            fieldKey: fieldKey,
            aiGenerated: true,
          });

          // Add end marker highlights
          if (field.endMarkers && Array.isArray(field.endMarkers) && field.endMarkers.length > 0) {
            for (const endMarker of field.endMarkers) {
              // Search for end marker after the field name
              const endIndex = fullText.indexOf(endMarker, index + field.fieldName.length);
              if (endIndex !== -1) {
                newHighlights.push({
                  id: `ai-endmarker-${Date.now()}-${Math.random()}`,
                  text: endMarker,
                  startIndex: endIndex,
                  endIndex: endIndex + endMarker.length,
                  label: `End marker for ${fieldKey}`,
                  labelType: 'end-marker',
                  noteType: firstNoteType,
                  fieldKey: fieldKey,
                  aiGenerated: true,
                });
              }
            }
          }
        }
      }
    }

    setHighlights(newHighlights);
  };

  const handleTextSelection = () => {
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0) return;

    const range = selection.getRangeAt(0);
    const selectedText = range.toString().trim();
    
    if (!selectedText || selectedText.length < 2) return;

    // Find the position in the full text
    const textNode = textRef.current;
    if (!textNode) return;

    // Get the plain text content (without HTML tags)
    const fullText = textNode.textContent || '';
    
    // Find the first occurrence of the selected text that's not already highlighted
    // We need to account for existing highlights by checking character positions
    let searchStart = 0;
    let startIndex = -1;
    let endIndex = -1;

    // Try to find the selection in the plain text
    // We'll use the range's start and end containers to get more accurate positions
    const startContainer = range.startContainer;
    const endContainer = range.endContainer;

    // Calculate position by walking through text nodes
    const walker = document.createTreeWalker(
      textNode,
      NodeFilter.SHOW_TEXT,
      null
    );

    let charCount = 0;
    let foundStart = false;
    let foundEnd = false;

    let node = walker.nextNode();
    while (node) {
      const nodeLength = node.textContent?.length || 0;
      
      if (node === startContainer && !foundStart) {
        startIndex = charCount + range.startOffset;
        foundStart = true;
      }
      
      if (node === endContainer && !foundEnd) {
        endIndex = charCount + range.endOffset;
        foundEnd = true;
        break;
      }
      
      charCount += nodeLength;
      node = walker.nextNode();
    }

    // Fallback: if we couldn't find exact positions, use text search
    if (startIndex === -1 || endIndex === -1) {
      const firstIndex = fullText.indexOf(selectedText, searchStart);
      if (firstIndex !== -1) {
        startIndex = firstIndex;
        endIndex = firstIndex + selectedText.length;
      } else {
        return; // Couldn't find the text
      }
    }

    // Check if this range overlaps with existing highlights
    const overlaps = highlights.some(h => {
      return (startIndex < h.endIndex && endIndex > h.startIndex);
    });

    if (!overlaps && startIndex >= 0 && endIndex > startIndex) {
      setSelectedText(selectedText);
      setSelectionStart(startIndex);
      setSelectionEnd(endIndex);
      
      // Show dialog to label the selection
      setCurrentHighlight({
        text: selectedText,
        startIndex,
        endIndex,
      });
    }
  };

  const handleLabelHighlight = (label: string, labelType: Highlight['labelType'], noteType?: string, fieldKey?: string) => {
    if (!currentHighlight) return;

    const highlight: Highlight = {
      id: `highlight-${Date.now()}-${Math.random()}`,
      text: currentHighlight.text || '',
      startIndex: currentHighlight.startIndex || 0,
      endIndex: currentHighlight.endIndex || 0,
      label,
      labelType,
      noteType,
      fieldKey,
    };

    setHighlights([...highlights, highlight]);
    setCurrentHighlight(null);
    setSelectedText('');
    
    // Clear selection
    window.getSelection()?.removeAllRanges();
  };

  const buildConfiguration = () => {
    if (!chainId || !chainName) {
      alert('Please enter chain ID and name');
      return;
    }

    // If editing, use existing config structure
    if (editingConfig && config) {
      const updatedConfig: OnboardingConfig = {
        ...config,
        chainId,
        chainName,
      };
      setConfig(updatedConfig);
      setStep('review');
      return;
    }

    // Group highlights by note type
    const noteTypeHighlights = highlights.filter(h => h.labelType === 'note-type');
    const fieldHighlights = highlights.filter(h => h.labelType === 'field-name');
    const endMarkerHighlights = highlights.filter(h => h.labelType === 'end-marker');

    const behaviourNoteTypes: string[] = [];
    const followUpNoteTypes: string[] = [];
    const noteTypeConfigs: Record<string, NoteTypeConfig> = {};

    // Process note types
    for (const noteHighlight of noteTypeHighlights) {
      const noteTypeName = noteHighlight.label;
      const isFollowUp = noteHighlight.text.toLowerCase().includes('follow') || 
                        noteHighlight.text.toLowerCase().includes('follow-up');
      
      if (isFollowUp) {
        followUpNoteTypes.push(noteTypeName);
      } else {
        behaviourNoteTypes.push(noteTypeName);
      }

      noteTypeConfigs[noteTypeName] = {
        name: noteTypeName,
        isFollowUp,
        fields: {},
      };
    }

    // Process fields
    for (const fieldHighlight of fieldHighlights) {
      const noteType = fieldHighlight.noteType || '';
      if (!noteType || !noteTypeConfigs[noteType]) continue;

      const fieldKey = fieldHighlight.fieldKey || fieldHighlight.label.toLowerCase().replace(/\s+/g, '_');
      const fieldName = fieldHighlight.text;

      // Find end markers for this field
      const endMarkers: string[] = [];
      for (const endMarker of endMarkerHighlights) {
        if (endMarker.noteType === noteType && endMarker.fieldKey === fieldKey) {
          endMarkers.push(endMarker.text);
        }
      }

      noteTypeConfigs[noteType].fields[fieldKey] = {
        fieldName,
        endMarkers,
      };
    }

    const newConfig: OnboardingConfig = {
      chainId,
      chainName,
      behaviourNoteTypes,
      followUpNoteTypes,
      noteTypeConfigs,
      excelFieldMappings: excelFieldMappings,
    };

    setConfig(newConfig);
    setStep('review');
  };

  const handleSaveConfiguration = async () => {
    if (!config) return;

    try {
      const response = await fetch('/api/admin/save-onboarding-config', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(config),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to save configuration');
      }

      const data = await response.json();
      
      alert(`Configuration saved successfully for ${config.chainName} (${config.chainId})!`);
      
      // Refresh saved configs list
      await loadSavedConfigs();
      
      // Reset wizard
      if (editingConfig) {
        setStep('saved');
        setEditingConfig(null);
      } else {
        setStep('upload');
        setPdfFile(null);
        setExcelFile(null);
        setPdfText('');
      setPdfPages([]);
      setExcelData(null);
      setHighlights([]);
      setExcelFieldMappings({});
      }
      setConfig(null);
      setChainId('');
      setChainName('');
      setAiSuggestions(null);
      setDataSourceMapping(null);
      setExcelFieldMappings({});
      setAiProgress({ percent: 0, message: '' });
    } catch (error) {
      console.error('Error saving configuration:', error);
      alert(`Failed to save configuration: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  };

  const normalizeConfig = (config: any): OnboardingConfig => {
    // Ensure all noteTypeConfigs have proper structure with fields
    const normalizedNoteTypeConfigs: Record<string, NoteTypeConfig> = {};
    
    if (config.noteTypeConfigs) {
      for (const [key, noteConfig] of Object.entries(config.noteTypeConfigs)) {
        normalizedNoteTypeConfigs[key] = {
          name: (noteConfig as any)?.name || key,
          isFollowUp: (noteConfig as any)?.isFollowUp || false,
          fields: (noteConfig as any)?.fields || {},
        };
      }
    }

    return {
      chainId: config.chainId || '',
      chainName: config.chainName || '',
      behaviourNoteTypes: config.behaviourNoteTypes || [],
      followUpNoteTypes: config.followUpNoteTypes || [],
      noteTypeConfigs: normalizedNoteTypeConfigs,
      excelFieldMappings: config.excelFieldMappings || {},
    };
  };

  const loadSavedConfigs = async () => {
    setLoadingConfigs(true);
    try {
      const response = await fetch('/api/admin/save-onboarding-config');
      if (response.ok) {
        const data = await response.json();
        // Normalize all configs to ensure they have proper structure
        const normalizedConfigs = (data.configs || []).map((config: any) => normalizeConfig(config));
        setSavedConfigs(normalizedConfigs);
      }
    } catch (error) {
      console.error('Error loading saved configs:', error);
    } finally {
      setLoadingConfigs(false);
    }
  };

  const handleViewSavedConfigs = async () => {
    await loadSavedConfigs();
    setStep('saved');
  };

  const handleLoadConfig = (savedConfig: OnboardingConfig) => {
    setViewingConfig(savedConfig);
  };

  const handleEditConfig = (savedConfig: OnboardingConfig) => {
    setEditingConfig(savedConfig);
    setChainId(savedConfig.chainId);
    setChainName(savedConfig.chainName);
    setConfig(savedConfig);
    setExcelFieldMappings(savedConfig.excelFieldMappings || {});
    setStep('edit-config');
  };

  const handleEditConfigSave = (updatedConfig: OnboardingConfig) => {
    setConfig(updatedConfig);
    setEditingConfig(updatedConfig); // Keep editingConfig set so save knows it's an update
    setStep('review');
  };

  const handleCloseViewConfig = () => {
    setViewingConfig(null);
  };

  const handleCancelEdit = () => {
    setEditingConfig(null);
    setChainId('');
    setChainName('');
    setConfig(null);
    setStep('saved');
  };

  const handleDeleteConfig = async (chainId: string) => {
    if (!confirm(`Are you sure you want to delete the configuration for ${chainId}? This action cannot be undone.`)) {
      return;
    }

    try {
      const response = await fetch(`/api/admin/save-onboarding-config?chainId=${chainId}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        throw new Error('Failed to delete configuration');
      }

      alert('Configuration deleted successfully');
      await loadSavedConfigs();
    } catch (error) {
      console.error('Error deleting configuration:', error);
      alert(`Failed to delete configuration: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  };

  const generateRFC = (config: OnboardingConfig) => {
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4',
    });

    const pageWidth = pdf.internal.pageSize.width;
    const pageHeight = pdf.internal.pageSize.height;
    const margin = 20;
    const lineHeight = 7;
    let yPos = margin;

    // Helper function to add a new page if needed
    const checkNewPage = (requiredSpace: number) => {
      if (yPos + requiredSpace > pageHeight - margin) {
        pdf.addPage();
        yPos = margin;
        return true;
      }
      return false;
    };

    // Helper function to add text with word wrap
    const addText = (text: string, fontSize: number, isBold: boolean = false, color: number[] = [0, 0, 0]) => {
      pdf.setFontSize(fontSize);
      pdf.setFont('helvetica', isBold ? 'bold' : 'normal');
      pdf.setTextColor(color[0], color[1], color[2]);
      
      const maxWidth = pageWidth - 2 * margin;
      const lines = pdf.splitTextToSize(text, maxWidth);
      
      checkNewPage(lines.length * lineHeight);
      
      lines.forEach((line: string) => {
        pdf.text(line, margin, yPos);
        yPos += lineHeight;
      });
      
      yPos += 2; // Add small spacing after text
    };

    // Title
    pdf.setFontSize(20);
    pdf.setFont('helvetica', 'bold');
    pdf.setTextColor(6, 182, 212);
    pdf.text('RFC: Onboarding Configuration', pageWidth / 2, yPos, { align: 'center' });
    yPos += 15;

    // Chain Information Section
    pdf.setFontSize(16);
    pdf.setFont('helvetica', 'bold');
    pdf.setTextColor(0, 0, 0);
    pdf.text('1. Chain Information', margin, yPos);
    yPos += 10;

    addText(`Chain ID: ${config.chainId}`, 12, true);
    addText(`Chain Name: ${config.chainName}`, 12, true);
    yPos += 5;

    // Note Types Section
    pdf.setFontSize(16);
    pdf.setFont('helvetica', 'bold');
    pdf.text('2. Note Types Configuration', margin, yPos);
    yPos += 10;

    addText('2.1 Behaviour Note Types', 14, true);
    if (config.behaviourNoteTypes.length > 0) {
      config.behaviourNoteTypes.forEach((type, index) => {
        addText(`${index + 1}. ${type}`, 11);
      });
    } else {
      addText('No behaviour note types configured', 11, false, [128, 128, 128]);
    }
    yPos += 5;

    addText('2.2 Follow-up Note Types', 14, true);
    if (config.followUpNoteTypes.length > 0) {
      config.followUpNoteTypes.forEach((type, index) => {
        addText(`${index + 1}. ${type}`, 11);
      });
    } else {
      addText('No follow-up note types configured', 11, false, [128, 128, 128]);
    }
    yPos += 5;

    // Field Extraction Markers Section
    pdf.setFontSize(16);
    pdf.setFont('helvetica', 'bold');
    checkNewPage(15);
    pdf.text('3. Field Extraction Markers', margin, yPos);
    yPos += 10;

    const noteTypeEntries = Object.entries(config.noteTypeConfigs);
    if (noteTypeEntries.length === 0) {
      addText('No note type configurations found', 11, false, [128, 128, 128]);
    } else {
      noteTypeEntries.forEach(([noteType, noteConfig], noteIndex) => {
        checkNewPage(20);
        addText(`3.${noteIndex + 1} Note Type: ${noteType}`, 14, true);
        addText(`Type: ${noteConfig.isFollowUp ? 'Follow-up Note' : 'Behaviour Note'}`, 11);
        yPos += 3;

        const fieldEntries = noteConfig.fields ? Object.entries(noteConfig.fields) : [];
        if (fieldEntries.length === 0) {
          addText('  No fields configured for this note type', 10, false, [128, 128, 128]);
        } else {
          fieldEntries.forEach(([fieldKey, fieldConfig], fieldIndex) => {
            checkNewPage(25);
            addText(`  Field ${fieldIndex + 1}: ${fieldKey}`, 12, true);
            addText(`    Field Name: "${fieldConfig.fieldName}"`, 10);
            if (fieldConfig.endMarkers && fieldConfig.endMarkers.length > 0) {
              addText(`    End Markers: ${fieldConfig.endMarkers.join(', ')}`, 10);
            } else {
              addText(`    End Markers: None specified`, 10, false, [128, 128, 128]);
            }
            yPos += 2;
          });
        }
        yPos += 5;
      });
    }

    // Code Section
    checkNewPage(30);
    pdf.setFontSize(16);
    pdf.setFont('helvetica', 'bold');
    pdf.text('4. Implementation Code', margin, yPos);
    yPos += 10;

    addText('4.1 TypeScript Configuration', 14, true);
    
    // Generate TypeScript code
    const formatTsValue = (value: any, indent: number = 2): string => {
      const spaces = ' '.repeat(indent);
      if (Array.isArray(value)) {
        if (value.length === 0) return '[]';
        return `[\n${value.map(v => `${spaces}  ${JSON.stringify(v)}`).join(',\n')}\n${spaces}]`;
      }
      if (typeof value === 'object' && value !== null) {
        const entries = Object.entries(value);
        if (entries.length === 0) return '{}';
        return `{\n${entries.map(([k, v]) => {
          const formattedValue = formatTsValue(v, indent + 2);
          return `${spaces}  ${k}: ${formattedValue}`;
        }).join(',\n')}\n${spaces}}`;
      }
      return JSON.stringify(value);
    };

    // Convert to ChainExtractionConfig format
    const chainConfig: ChainExtractionConfig = {
      behaviourNoteTypes: config.behaviourNoteTypes,
      followUpNoteTypes: config.followUpNoteTypes,
      extraFollowUpNoteTypes: [],
      injuryColumns: {
        start: 13,
        end: 87,
      },
      fieldExtractionMarkers: {},
      hasTimeFrequency: false,
      hasEvaluation: false,
    };

    // Merge field extraction markers from all note types
    // For now, we'll use the first note type's fields as the primary configuration
    // In a more sophisticated system, we could handle different fields per note type
    const firstNoteType = Object.keys(config.noteTypeConfigs)[0];
    if (firstNoteType) {
      const noteConfig = config.noteTypeConfigs[firstNoteType];
      if (noteConfig.fields) {
        for (const [fieldKey, fieldConfig] of Object.entries(noteConfig.fields)) {
          chainConfig.fieldExtractionMarkers[fieldKey] = {
            fieldName: fieldConfig.fieldName,
            endMarkers: fieldConfig.endMarkers || [],
          };
        }
      }
    }

    const tsConfig = formatTsValue(chainConfig, 2);
    const tsCode = `${config.chainId}: ${tsConfig},`;

    // Add code with monospace font
    pdf.setFont('courier', 'normal');
    pdf.setFontSize(9);
    pdf.setTextColor(0, 0, 0);
    
    const codeLines = pdf.splitTextToSize(tsCode, pageWidth - 2 * margin);
    codeLines.forEach((line: string) => {
      checkNewPage(lineHeight);
      pdf.text(line, margin, yPos);
      yPos += lineHeight;
    });

    // Instructions
    yPos += 5;
    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(11);
    addText('4.2 Implementation Instructions', 14, true);
    addText('Add the above configuration to the CHAIN_EXTRACTION_CONFIGS object in src/lib/processing/homesDb.ts', 10);
    addText('Location: src/lib/processing/homesDb.ts', 10, false, [128, 128, 128]);
    addText('Object: CHAIN_EXTRACTION_CONFIGS', 10, false, [128, 128, 128]);

    // Footer
    const totalPages = pdf.internal.pages.length - 1;
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      pdf.setFontSize(8);
      pdf.setTextColor(128, 128, 128);
      pdf.text(
        `RFC - ${config.chainName} (${config.chainId}) - Page ${i} of ${totalPages}`,
        pageWidth / 2,
        pageHeight - 10,
        { align: 'center' }
      );
    }

    // Save PDF
    pdf.save(`RFC_${config.chainId}_${new Date().toISOString().split('T')[0]}.pdf`);
  };

  const renderHighlightedText = () => {
    if (!pdfText) return null;

    let result = pdfText;
    const sortedHighlights = [...highlights].sort((a, b) => a.startIndex - b.startIndex);

    // Build HTML with highlights
    let html = '';
    let lastIndex = 0;

    for (const highlight of sortedHighlights) {
      // Add text before highlight
      html += escapeHtml(result.substring(lastIndex, highlight.startIndex));
      
      // Add highlighted text
      const color = highlight.labelType === 'note-type' ? '#fef3c7' : 
                   highlight.labelType === 'field-name' ? '#dbeafe' : 
                   highlight.labelType === 'end-marker' ? '#fce7f3' : '#e5e7eb';
      html += `<mark style="background-color: ${color}; padding: 2px 4px; border-radius: 3px;" title="${highlight.label}">${escapeHtml(highlight.text)}</mark>`;
      
      lastIndex = highlight.endIndex;
    }

    // Add remaining text
    html += escapeHtml(result.substring(lastIndex));

    return html;
  };

  const escapeHtml = (text: string) => {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  };

  return (
    <div className="bg-white rounded-lg shadow-sm p-6">
      {/* Progress Steps */}
      {step !== 'saved' && (
        <div className="mb-8">
          <div className="flex items-center justify-between">
            {['upload', 'highlight', 'configure', 'review'].map((s, index) => (
              <React.Fragment key={s}>
                <div className="flex items-center">
                  <div
                    className={`w-10 h-10 rounded-full flex items-center justify-center font-semibold ${
                      step === s
                        ? 'bg-cyan-500 text-white'
                        : index < ['upload', 'highlight', 'configure', 'review'].indexOf(step)
                        ? 'bg-green-500 text-white'
                        : 'bg-gray-200 text-gray-600'
                    }`}
                  >
                    {index + 1}
                  </div>
                  <span className="ml-2 text-sm font-medium text-gray-700 capitalize">{s}</span>
                </div>
                {index < 3 && <div className="flex-1 h-1 mx-4 bg-gray-200" />}
              </React.Fragment>
            ))}
          </div>
        </div>
      )}

      {/* Step 1: Upload PDF and Excel */}
      {step === 'upload' && (
        <div className="space-y-6">
          <div className="flex justify-between items-start">
            <div>
              <h2 className="text-xl font-semibold text-gray-900 mb-2">Upload Sample Files</h2>
              <p className="text-gray-600 mb-4">
                Upload both PDF and Excel files. The Excel file contains 8 fields (incident_number, name, date, time, incident_location, room, injuries, incident_type), 
                while the PDF contains 6 fields (behaviour_type, triggers, interventions, poa_notified, time_frequency, evaluation). Both are needed for complete data extraction.
              </p>
            </div>
            <button
              onClick={handleViewSavedConfigs}
              className="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition-colors"
            >
              View Saved Configurations
            </button>
          </div>
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* PDF Upload */}
            <div className="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center">
              <h3 className="text-lg font-semibold text-gray-900 mb-2">PDF File</h3>
              <p className="text-sm text-gray-600 mb-4">
                Contains behaviour notes with field labels
              </p>
              <input
                type="file"
                accept=".pdf"
                onChange={handlePdfUpload}
                className="hidden"
                id="pdf-upload"
              />
              <label
                htmlFor="pdf-upload"
                className="cursor-pointer inline-block px-6 py-3 bg-cyan-500 text-white rounded-lg hover:bg-cyan-600 transition-colors"
              >
                Choose PDF File
              </label>
              {pdfFile && (
                <p className="mt-4 text-sm text-gray-600">Selected: {pdfFile.name}</p>
              )}
            </div>

            {/* Excel Upload */}
            <div className="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center">
              <h3 className="text-lg font-semibold text-gray-900 mb-2">Excel File</h3>
              <p className="text-sm text-gray-600 mb-4">
                Contains base incident records
              </p>
              <input
                type="file"
                accept=".xls,.xlsx"
                onChange={handleExcelUpload}
                className="hidden"
                id="excel-upload"
              />
              <label
                htmlFor="excel-upload"
                className="cursor-pointer inline-block px-6 py-3 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors"
              >
                Choose Excel File
              </label>
              {excelFile && (
                <p className="mt-4 text-sm text-gray-600">Selected: {excelFile.name}</p>
              )}
            </div>
          </div>

          {/* Analyze Files Button */}
          {(pdfFile || excelFile) && !aiLoading && !aiSuggestions && (
            <div className="mt-6 text-center">
              <button
                onClick={handleAnalyzeFiles}
                className="px-6 py-3 bg-purple-500 text-white rounded-lg hover:bg-purple-600 transition-colors font-semibold"
              >
                {pdfFile && excelFile 
                  ? 'Analyze Both Files with AI' 
                  : `Analyze ${pdfFile ? 'PDF' : 'Excel'} File with AI`}
              </button>
              <p className="text-xs text-gray-500 mt-2">
                {pdfFile && excelFile 
                  ? 'Both files uploaded. Click to analyze and extract field mappings.'
                  : 'Upload both files for complete analysis, or proceed with current file.'}
              </p>
            </div>
          )}

          {aiLoading && (
            <div className="mt-4 p-4 bg-blue-50 rounded-lg border border-blue-200">
              <div className="space-y-3">
                <div className="flex items-center space-x-3">
                  <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-500"></div>
                  <p className="text-sm font-medium text-blue-700">
                    {aiProgress.message || 'AI is analyzing the files and generating field mappings...'}
                  </p>
                </div>
                <div className="w-full bg-blue-200 rounded-full h-2.5">
                  <div
                    className="bg-blue-600 h-2.5 rounded-full transition-all duration-300 ease-out"
                    style={{ width: `${aiProgress.percent}%` }}
                  ></div>
                </div>
                <p className="text-xs text-blue-600 text-right">
                  {aiProgress.percent}% complete
                </p>
              </div>
            </div>
          )}
          
          {aiSuggestions && !aiLoading && (
            <div className="mt-4 p-4 bg-green-50 border border-green-200 rounded-lg">
              <div className="flex items-start justify-between">
                <div>
                  <p className="text-sm font-medium text-green-800 mb-2">
                    ✓ AI Analysis Complete
                  </p>
                  <p className="text-xs text-green-700 mb-2">
                    Found {Object.keys(aiSuggestions.excelFieldMappings || {}).length} Excel field mappings,{' '}
                    {aiSuggestions.behaviourNoteTypes?.length || 0} behaviour note types,{' '}
                    {aiSuggestions.followUpNoteTypes?.length || 0} follow-up note types, and{' '}
                    {Object.keys(aiSuggestions.fieldExtractionMarkers || {}).length} PDF field mappings.
                    Review and edit the mappings below.
                  </p>
                  {dataSourceMapping && (
                    <div className="mt-2 text-xs text-green-700">
                      <p className="font-semibold">Data Sources:</p>
                      <p><strong>Excel (8 fields):</strong> {dataSourceMapping.excel?.join(', ') || 'N/A'}</p>
                      <p><strong>PDF (6 fields):</strong> {dataSourceMapping.pdf?.join(', ') || 'N/A'}</p>
                      {dataSourceMapping.both && dataSourceMapping.both.length > 0 && (
                        <div className="mt-1">
                          <p className="text-yellow-700 font-semibold">Overlapping Fields:</p>
                          {dataSourceMapping.both.map((field: string) => (
                            <p key={field} className="text-yellow-700 ml-2">
                              • {field}: {dataSourceMapping.overlapRules?.[field] || 'Both sources'}
                            </p>
                          ))}
                        </div>
                      )}
                    </div>
                  )}
                </div>
                <button
                  onClick={() => {
                    setAiSuggestions(null);
                    setDataSourceMapping(null);
                  }}
                  className="text-green-600 hover:text-green-800 text-sm"
                >
                  Dismiss
                </button>
              </div>
            </div>
          )}
        </div>
      )}

      {/* Step 2: Highlight and Label */}
      {step === 'highlight' && (
        <div className="space-y-6">
          <div>
            <h2 className="text-xl font-semibold text-gray-900 mb-2">Review Files and Label Sections</h2>
            <p className="text-gray-600 mb-4">
              Review both files below. The Excel file provides base incident data, while the PDF contains behaviour notes. 
              Select text in the PDF and label what it represents. You can label:
            </p>
            <ul className="list-disc list-inside text-gray-600 mb-4 space-y-1">
              <li><strong>Note Types</strong> - The type of note (e.g., "Behaviour - Responsive Behaviour", "Behaviour - Follow up") - from PDF</li>
              <li><strong>Field Names</strong> - The labels for fields (e.g., "Type of Behaviour :", "Interventions :") - from PDF</li>
              <li><strong>End Markers</strong> - Text that marks the end of a field (e.g., "Antecedent/Triggers", "Page") - from PDF</li>
            </ul>
            <div className="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4">
              <p className="text-sm text-blue-800">
                <strong>Data Source:</strong> Excel provides 8 fields (incident_number, name, date, time, incident_location, room, injuries, incident_type). 
                PDF provides 6 fields (behaviour_type, triggers, interventions, poa_notified, time_frequency, evaluation). 
                Overlapping fields (name, date, time, injuries): Excel values are used for name/date/time; injuries defaults to Excel but can be replaced by PDF if matching note found.
              </p>
            </div>
          </div>

          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* PDF Text Display */}
            {pdfText && (
              <div className="border rounded-lg p-4 bg-gray-50 max-h-[600px] overflow-y-auto">
                <h3 className="font-semibold mb-2 text-gray-900">PDF Content (Behaviour Notes)</h3>
                <p className="text-xs text-gray-600 mb-2">Contains 6 fields: behaviour_type, triggers, interventions, poa_notified, time_frequency (optional), evaluation (optional)</p>
                <div
                  ref={textRef}
                  onMouseUp={handleTextSelection}
                  className="whitespace-pre-wrap font-mono text-sm"
                  dangerouslySetInnerHTML={{ __html: renderHighlightedText() || escapeHtml(pdfText) }}
                />
              </div>
            )}

            {/* Excel Data Display */}
            {excelData && (
              <div className="border rounded-lg p-4 bg-gray-50 max-h-[600px] overflow-y-auto">
                <h3 className="font-semibold mb-2 text-gray-900">Excel Data (Base Incident Records)</h3>
                <p className="text-xs text-gray-600 mb-2">Click column headers to map them to fields. Contains 8 fields: incident_number, name, date, time, incident_location, room, injuries, incident_type</p>
                <div className="overflow-x-auto">
                  <table className="min-w-full text-xs border-collapse">
                    <thead>
                      <tr className="bg-gray-200">
                        {excelData.headers.slice(0, 10).map((header, idx) => {
                          const isMapped = Object.values(excelFieldMappings).some(m => m.excelColumn === header);
                          return (
                            <th
                              key={idx}
                              onClick={() => {
                                const fieldKey = prompt(`Map column "${header}" to which field?\n\nOptions: incident_number, name, date, time, incident_location, room, injuries, incident_type`);
                                if (fieldKey) {
                                  setExcelFieldMappings({
                                    ...excelFieldMappings,
                                    [fieldKey]: {
                                      excelColumn: header,
                                      confidence: 1.0,
                                      reasoning: 'Manually mapped',
                                      dataSource: 'EXCEL' as const,
                                    },
                                  });
                                }
                              }}
                              className={`border px-2 py-1 text-left font-semibold cursor-pointer hover:bg-blue-200 transition-colors ${
                                isMapped ? 'bg-green-200' : ''
                              }`}
                              title={isMapped ? `Mapped to: ${Object.entries(excelFieldMappings).find(([_, m]) => m.excelColumn === header)?.[0]}` : 'Click to map this column'}
                            >
                              {header} {isMapped && '✓'}
                            </th>
                          );
                        })}
                      </tr>
                    </thead>
                    <tbody>
                      {excelData.rows.slice(0, 20).map((row, rowIdx) => (
                        <tr key={rowIdx} className="border-b">
                          {excelData.headers.slice(0, 10).map((header, colIdx) => (
                            <td key={colIdx} className="border px-2 py-1">
                              {String(row[header] || '').substring(0, 30)}
                            </td>
                          ))}
                        </tr>
                      ))}
                    </tbody>
                  </table>
                  {excelData.rows.length > 20 && (
                    <p className="text-xs text-gray-500 mt-2">
                      Showing first 20 of {excelData.rows.length} rows
                    </p>
                  )}
                </div>
              </div>
            )}

            {/* If only one file is uploaded, show it in full width */}
            {!pdfText && !excelData && (
              <div className="col-span-2 text-center text-gray-500 p-8">
                Please upload at least one file (PDF or Excel) to proceed
              </div>
            )}
          </div>

          {/* Warning if only one file is uploaded */}
          {(pdfText && !excelData) || (!pdfText && excelData) ? (
            <div className="mt-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
              <p className="text-sm text-yellow-800">
                <strong>Note:</strong> For complete automatic onboarding, both PDF and Excel files are recommended. 
                {pdfText && !excelData && ' Excel file provides 8 fields (incident_number, name, date, time, incident_location, room, injuries, incident_type).'}
                {!pdfText && excelData && ' PDF file provides behaviour note details (behaviour_type, triggers, description, interventions, etc.).'}
                {' '}The system merges Excel incidents with PDF notes by matching resident name and time window.
              </p>
            </div>
          ) : null}

          {/* Excel Field Mappings */}
          {excelData && (
            <div className="mt-4 border rounded-lg p-4 bg-green-50">
              <div className="flex justify-between items-center mb-3">
                <div>
                  <h3 className="font-semibold text-gray-900">Excel Field Mappings</h3>
                  <p className="text-xs text-gray-600 mt-1">
                    Excel provides 8 fields: incident_number, name, date, time, incident_location, room, injuries, incident_type. 
                    Click column headers in the table above to map them.
                  </p>
                </div>
                <button
                  onClick={() => {
                    const fieldKey = prompt('Enter field key (e.g., incident_number, name, date, time, incident_location, room, injuries, incident_type):');
                    if (fieldKey && excelData) {
                      const column = prompt('Enter Excel column name:');
                      if (column) {
                        setExcelFieldMappings({
                          ...excelFieldMappings,
                          [fieldKey]: {
                            excelColumn: column,
                            confidence: 1.0,
                            reasoning: 'Manually mapped',
                            dataSource: 'EXCEL' as const,
                          },
                        });
                      }
                    }
                  }}
                  className="px-3 py-1 text-xs bg-green-600 text-white rounded hover:bg-green-700"
                >
                  + Add Mapping
                </button>
              </div>

              {/* Separate sections for EXCEL, PDF, and BOTH */}
              {(() => {
                // Check which fields are in both PDF and Excel
                const fieldsInBoth = highlights
                  .filter(h => h.labelType === 'field-name' && h.fieldKey)
                  .map(h => h.fieldKey!)
                  .filter(fieldKey => Object.keys(excelFieldMappings).includes(fieldKey));

                // Update mappings to mark fields as BOTH if they appear in PDF highlights
                const updatedMappings = { ...excelFieldMappings };
                fieldsInBoth.forEach(fieldKey => {
                  if (updatedMappings[fieldKey] && updatedMappings[fieldKey].dataSource !== 'BOTH') {
                    updatedMappings[fieldKey] = {
                      ...updatedMappings[fieldKey],
                      dataSource: 'BOTH' as const,
                    };
                  }
                });
                if (JSON.stringify(updatedMappings) !== JSON.stringify(excelFieldMappings)) {
                  setExcelFieldMappings(updatedMappings);
                }

                const excelOnly = Object.entries(excelFieldMappings).filter(([fieldKey, m]) => 
                  m.dataSource === 'EXCEL' && !fieldsInBoth.includes(fieldKey)
                );
                const bothFields = Object.entries(excelFieldMappings).filter(([fieldKey, m]) => 
                  m.dataSource === 'BOTH' || fieldsInBoth.includes(fieldKey)
                );

                return (
                  <div className="space-y-4">
                    {/* Excel Only Fields */}
                    {excelOnly.length > 0 && (
                      <div>
                        <h4 className="text-sm font-semibold text-green-800 mb-2">Excel Only Fields</h4>
                        <div className="space-y-2 max-h-[200px] overflow-y-auto">
                          {excelOnly.map(([fieldKey, mapping]) => (
                            <div key={fieldKey} className="border-l-4 border-green-400 pl-3 py-2 bg-white rounded">
                              <div className="flex items-center justify-between">
                                <div className="flex-1">
                                  <div className="flex items-center space-x-2">
                                    <span className="font-semibold text-green-900">{fieldKey}</span>
                                    {mapping.confidence && (
                                      <span className="text-xs text-gray-500">
                                        ({Math.round(mapping.confidence * 100)}% confidence)
                                      </span>
                                    )}
                                  </div>
                                  <p className="text-sm text-gray-700 mt-1">
                                    <strong>Excel Column:</strong> "{mapping.excelColumn || 'Not found'}"
                                  </p>
                                  {mapping.reasoning && (
                                    <p className="text-xs text-gray-600 mt-1 italic">{mapping.reasoning}</p>
                                  )}
                                </div>
                                <div className="flex space-x-2">
                                  <button
                                    onClick={() => {
                                      const pdfHighlight = highlights.find(h => h.fieldKey === fieldKey && h.labelType === 'field-name');
                                      if (pdfHighlight) {
                                        setExcelFieldMappings({
                                          ...excelFieldMappings,
                                          [fieldKey]: {
                                            ...mapping,
                                            dataSource: 'BOTH' as const,
                                          },
                                        });
                                      } else {
                                        alert('This field is not found in PDF highlights. Please highlight it in the PDF first.');
                                      }
                                    }}
                                    className="px-2 py-1 text-xs bg-purple-100 text-purple-700 rounded hover:bg-purple-200"
                                    title="Mark as BOTH if also in PDF"
                                  >
                                    Mark as BOTH
                                  </button>
                                  <button
                                    onClick={() => {
                                      const newMappings = { ...excelFieldMappings };
                                      delete newMappings[fieldKey];
                                      setExcelFieldMappings(newMappings);
                                    }}
                                    className="px-2 py-1 text-xs bg-red-100 text-red-700 rounded hover:bg-red-200"
                                  >
                                    Remove
                                  </button>
                                </div>
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}

                    {/* BOTH Fields */}
                    {bothFields.length > 0 && (
                      <div>
                        <h4 className="text-sm font-semibold text-purple-800 mb-2">Fields in Both Excel and PDF</h4>
                        <div className="space-y-2 max-h-[300px] overflow-y-auto">
                          {bothFields.map(([fieldKey, mapping]) => {
                            const pdfHighlight = highlights.find(h => h.fieldKey === fieldKey && h.labelType === 'field-name');
                            return (
                              <div key={fieldKey} className="border-l-4 border-purple-400 pl-3 py-2 bg-white rounded">
                                <div className="flex items-center justify-between">
                                  <div className="flex-1">
                                    <div className="flex items-center space-x-2">
                                      <span className="font-semibold text-purple-900">{fieldKey}</span>
                                      <span className="px-2 py-0.5 rounded text-xs bg-purple-100 text-purple-800">
                                        BOTH
                                      </span>
                                    </div>
                                    <div className="mt-2 space-y-1">
                                      <p className="text-sm text-gray-700">
                                        <strong>Excel Column:</strong> "{mapping.excelColumn || 'Not found'}"
                                      </p>
                                      {pdfHighlight ? (
                                        <p className="text-sm text-gray-700">
                                          <strong>PDF Field:</strong> "{pdfHighlight.text}"
                                        </p>
                                      ) : (
                                        <p className="text-xs text-yellow-600 italic">
                                          Not found in PDF highlights - please highlight this field in the PDF
                                        </p>
                                      )}
                                    </div>
                                    {mapping.reasoning && (
                                      <p className="text-xs text-gray-600 mt-1 italic">{mapping.reasoning}</p>
                                    )}
                                  </div>
                                  <button
                                    onClick={() => {
                                      const newMappings = { ...excelFieldMappings };
                                      delete newMappings[fieldKey];
                                      setExcelFieldMappings(newMappings);
                                    }}
                                    className="ml-2 px-2 py-1 text-xs bg-red-100 text-red-700 rounded hover:bg-red-200"
                                  >
                                    Remove
                                  </button>
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    )}
                  </div>
                );
              })()}
            </div>
          )}

          {/* Highlights Panel */}
          <div className="space-y-4">
              <div className="border rounded-lg p-4">
                <h3 className="font-semibold mb-3">Current Selection</h3>
                {selectedText ? (
                  <div className="space-y-2">
                    <p className="text-sm text-gray-600 bg-gray-100 p-2 rounded">{selectedText.substring(0, 100)}...</p>
                    <button
                      onClick={() => setCurrentHighlight({
                        text: selectedText,
                        startIndex: selectionStart,
                        endIndex: selectionEnd,
                      })}
                      className="w-full px-4 py-2 bg-cyan-500 text-white rounded hover:bg-cyan-600"
                    >
                      Label This Selection
                    </button>
                  </div>
                ) : (
                  <p className="text-sm text-gray-500">Select text in the PDF to label it</p>
                )}
              </div>

              <div className="border rounded-lg p-4">
                <div className="flex justify-between items-center mb-3">
                  <h3 className="font-semibold">PDF Highlights ({highlights.length})</h3>
                  {highlights.some(h => h.aiGenerated) && (
                    <button
                      onClick={() => setHighlights(highlights.filter(h => !h.aiGenerated))}
                      className="text-xs px-2 py-1 bg-gray-100 text-gray-700 rounded hover:bg-gray-200"
                    >
                      Clear AI Highlights
                    </button>
                  )}
                </div>
                <p className="text-xs text-gray-600 mb-3">
                  These highlights are for PDF fields. Excel field mappings are shown above.
                </p>
                <div className="space-y-4 max-h-[400px] overflow-y-auto">
                  {(() => {
                    // Group highlights by note type
                    const noteTypeHighlights = highlights.filter(h => h.labelType === 'note-type');
                    const fieldHighlights = highlights.filter(h => h.labelType === 'field-name');
                    const endMarkerHighlights = highlights.filter(h => h.labelType === 'end-marker');
                    const otherHighlights = highlights.filter(h => h.labelType === 'other');

                    // Create hierarchical structure
                    const hierarchicalStructure = noteTypeHighlights.map(noteType => {
                      const fieldsForNoteType = fieldHighlights.filter(f => f.noteType === noteType.label);
                      return { noteType, fields: fieldsForNoteType };
                    });

                    return (
                      <>
                        {/* Hierarchical view: Note types with their fields */}
                        {hierarchicalStructure.map(({ noteType, fields }) => (
                          <div key={noteType.id} className="border-l-4 border-yellow-400 pl-3">
                            {/* Note Type */}
                            <div className={`text-sm p-2 rounded mb-2 ${noteType.aiGenerated ? 'bg-yellow-100 border border-yellow-300' : 'bg-yellow-50'}`}>
                              <div className="flex items-center justify-between">
                                <div className="flex items-center space-x-2">
                                  <span className="font-semibold text-yellow-900">{noteType.label}</span>
                                  {noteType.aiGenerated && (
                                    <span className="px-1.5 py-0.5 rounded text-xs bg-purple-100 text-purple-700 border border-purple-300">
                                      AI
                                    </span>
                                  )}
                                </div>
                                <span className="px-2 py-1 rounded text-xs bg-yellow-100 text-yellow-800">
                                  note-type
                                </span>
                              </div>
                              <p className="text-xs text-yellow-700 mt-1 truncate">{noteType.text.substring(0, 60)}...</p>
                            </div>

                            {/* Fields under this note type */}
                            {fields.length > 0 && (
                              <div className="ml-4 space-y-2 mt-2">
                                {fields.map((field) => {
                                  const endMarkersForField = endMarkerHighlights.filter(
                                    em => em.noteType === noteType.label && em.fieldKey === field.fieldKey
                                  );
                                  
                                  return (
                                    <div key={field.id} className="border-l-2 border-blue-300 pl-3">
                                      {/* Field Name */}
                                      <div className={`text-sm p-2 rounded ${field.aiGenerated ? 'bg-blue-100 border border-blue-300' : 'bg-blue-50'}`}>
                                        <div className="flex items-center justify-between">
                                          <div className="flex items-center space-x-2">
                                            <span className="font-medium text-blue-900">{field.label}</span>
                                            {field.aiGenerated && (
                                              <span className="px-1.5 py-0.5 rounded text-xs bg-purple-100 text-purple-700 border border-purple-300">
                                                AI
                                              </span>
                                            )}
                                          </div>
                                          <span className="px-2 py-1 rounded text-xs bg-blue-100 text-blue-800">
                                            field-name
                                          </span>
                                        </div>
                                        <p className="text-xs text-blue-700 mt-1 truncate">{field.text.substring(0, 50)}...</p>
                                      </div>

                                      {/* End Markers for this field */}
                                      {endMarkersForField.length > 0 && (
                                        <div className="ml-4 space-y-1 mt-1">
                                          {endMarkersForField.map((endMarker) => (
                                            <div key={endMarker.id} className={`text-xs p-1.5 rounded border-l-2 border-pink-300 ${endMarker.aiGenerated ? 'bg-pink-100 border border-pink-300' : 'bg-pink-50'}`}>
                                              <div className="flex items-center justify-between">
                                                <div className="flex items-center space-x-2">
                                                  <span className="text-pink-900">{endMarker.text.substring(0, 40)}...</span>
                                                  {endMarker.aiGenerated && (
                                                    <span className="px-1.5 py-0.5 rounded text-xs bg-purple-100 text-purple-700 border border-purple-300">
                                                      AI
                                                    </span>
                                                  )}
                                                </div>
                                                <span className="px-1.5 py-0.5 rounded text-xs bg-pink-100 text-pink-800">
                                                  end-marker
                                                </span>
                                              </div>
                                            </div>
                                          ))}
                                        </div>
                                      )}
                                    </div>
                                  );
                                })}
                              </div>
                            )}
                          </div>
                        ))}

                        {/* Standalone fields (not associated with a note type) */}
                        {fieldHighlights.filter(f => !f.noteType).length > 0 && (
                          <div className="mt-4 pt-4 border-t">
                            <p className="text-xs text-gray-500 mb-2 font-medium">Unassigned Fields</p>
                            {fieldHighlights.filter(f => !f.noteType).map((field) => (
                              <div key={field.id} className="text-sm p-2 bg-gray-50 rounded mb-2">
                                <div className="flex items-center justify-between">
                                  <span className="font-medium">{field.label}</span>
                                  <span className="px-2 py-1 rounded text-xs bg-blue-100 text-blue-800">
                                    field-name
                                  </span>
                                </div>
                                <p className="text-xs text-gray-500 mt-1 truncate">{field.text.substring(0, 50)}...</p>
                              </div>
                            ))}
                          </div>
                        )}

                        {/* Other highlights */}
                        {otherHighlights.length > 0 && (
                          <div className="mt-4 pt-4 border-t">
                            <p className="text-xs text-gray-500 mb-2 font-medium">Other</p>
                            {otherHighlights.map((h) => (
                              <div key={h.id} className="text-sm p-2 bg-gray-50 rounded mb-2">
                                <div className="flex items-center justify-between">
                                  <span className="font-medium">{h.label}</span>
                                  <span className="px-2 py-1 rounded text-xs bg-gray-100 text-gray-800">
                                    {h.labelType}
                                  </span>
                                </div>
                                <p className="text-xs text-gray-500 mt-1 truncate">{h.text.substring(0, 50)}...</p>
                              </div>
                            ))}
                          </div>
                        )}
                      </>
                    );
                  })()}
                </div>
              </div>

              <button
                onClick={() => setStep('configure')}
                disabled={highlights.length === 0 && !pdfText}
                className="w-full px-4 py-2 bg-cyan-500 text-white rounded hover:bg-cyan-600 disabled:bg-gray-300 disabled:cursor-not-allowed"
              >
                Continue to Configuration
              </button>
              {highlights.length === 0 && pdfText && (
                <p className="text-xs text-gray-500 mt-2 text-center">
                  Tip: Select and label text in the PDF to identify note types and field names
                </p>
              )}
          </div>

          {/* Label Dialog */}
          {currentHighlight && (
            <LabelDialog
              highlight={currentHighlight}
              existingHighlights={highlights}
              onSave={handleLabelHighlight}
              onCancel={() => setCurrentHighlight(null)}
            />
          )}
        </div>
      )}

      {/* Step: Edit Configuration */}
      {step === 'edit-config' && editingConfig && (
        <EditConfigurationView
          config={editingConfig}
          chainId={chainId}
          chainName={chainName}
          onChainIdChange={setChainId}
          onChainNameChange={setChainName}
          onSave={handleEditConfigSave}
          onCancel={handleCancelEdit}
        />
      )}

      {/* Step 3: Configure */}
      {step === 'configure' && (
        <div className="space-y-6">
          <div>
            <h2 className="text-xl font-semibold text-gray-900 mb-2">Configure Chain Settings</h2>
            <p className="text-gray-600 mb-4">
              Enter the chain information and organize the highlighted fields.
            </p>
          </div>

          <div className="grid grid-cols-2 gap-6">
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Chain ID *
                </label>
                <input
                  type="text"
                  value={chainId}
                  onChange={(e) => setChainId(e.target.value)}
                  className="w-full px-3 py-2 border rounded-lg"
                  placeholder="e.g., mill_creek"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Chain Name *
                </label>
                <input
                  type="text"
                  value={chainName}
                  onChange={(e) => setChainName(e.target.value)}
                  className="w-full px-3 py-2 border rounded-lg"
                  placeholder="e.g., Mill Creek Care"
                />
              </div>
            </div>

            <div className="border rounded-lg p-4">
              <h3 className="font-semibold mb-3">Field Organization</h3>
              <p className="text-sm text-gray-600">
                Review your highlights and ensure they are properly organized. You can go back to add more highlights if needed.
              </p>
              <div className="mt-4 space-y-2">
                <div className="text-sm">
                  <span className="font-medium">Note Types:</span>{' '}
                  {highlights.filter(h => h.labelType === 'note-type').length}
                </div>
                <div className="text-sm">
                  <span className="font-medium">Field Names:</span>{' '}
                  {highlights.filter(h => h.labelType === 'field-name').length}
                </div>
                <div className="text-sm">
                  <span className="font-medium">End Markers:</span>{' '}
                  {highlights.filter(h => h.labelType === 'end-marker').length}
                </div>
              </div>
            </div>
          </div>

          <div className="flex space-x-4">
            <button
              onClick={() => setStep('highlight')}
              className="px-4 py-2 border rounded-lg text-gray-700 hover:bg-gray-50"
            >
              Back
            </button>
            <button
              onClick={buildConfiguration}
              disabled={!chainId || !chainName}
              className="px-4 py-2 bg-cyan-500 text-white rounded-lg hover:bg-cyan-600 disabled:bg-gray-300 disabled:cursor-not-allowed"
            >
              Build Configuration
            </button>
          </div>
        </div>
      )}

      {/* Step 4: Review */}
      {step === 'review' && config && (
        <div className="space-y-6">
          <div>
            <h2 className="text-xl font-semibold text-gray-900 mb-2">Review Configuration</h2>
            <p className="text-gray-600 mb-4">
              Review the generated configuration before saving.
            </p>
          </div>

          <div className="border rounded-lg p-6 space-y-4">
            <div>
              <h3 className="font-semibold mb-2">Chain Information</h3>
              <div className="grid grid-cols-2 gap-4 text-sm">
                <div>
                  <span className="text-gray-600">Chain ID:</span>{' '}
                  <span className="font-medium">{config.chainId}</span>
                </div>
                <div>
                  <span className="text-gray-600">Chain Name:</span>{' '}
                  <span className="font-medium">{config.chainName}</span>
                </div>
              </div>
            </div>

            <div>
              <h3 className="font-semibold mb-2">Behaviour Note Types</h3>
              <ul className="list-disc list-inside text-sm text-gray-700">
                {config.behaviourNoteTypes.map((type, i) => (
                  <li key={i}>{type}</li>
                ))}
              </ul>
            </div>

            <div>
              <h3 className="font-semibold mb-2">Follow-up Note Types</h3>
              <ul className="list-disc list-inside text-sm text-gray-700">
                {config.followUpNoteTypes.map((type, i) => (
                  <li key={i}>{type}</li>
                ))}
              </ul>
            </div>

            <div>
              <h3 className="font-semibold mb-2">Field Extraction Markers (PDF)</h3>
              <div className="space-y-3">
                {Object.entries(config.noteTypeConfigs).map(([noteType, noteConfig]) => (
                  <div key={noteType} className="border-l-4 border-cyan-500 pl-4">
                    <h4 className="font-medium text-sm mb-2">{noteConfig?.name || noteType}</h4>
                    {noteConfig?.fields && Object.entries(noteConfig.fields).length > 0 ? (
                      <ul className="text-sm text-gray-700 space-y-1">
                        {Object.entries(noteConfig.fields).map(([fieldKey, fieldConfig]) => (
                          <li key={fieldKey}>
                            <span className="font-medium">{fieldKey}:</span>{' '}
                            <span className="text-gray-600">"{fieldConfig.fieldName}"</span>
                            {fieldConfig.endMarkers && fieldConfig.endMarkers.length > 0 && (
                              <span className="text-gray-500 text-xs ml-2">
                                (ends at: {fieldConfig.endMarkers.join(', ')})
                              </span>
                            )}
                          </li>
                        ))}
                      </ul>
                    ) : (
                      <p className="text-xs text-gray-500">No fields configured</p>
                    )}
                  </div>
                ))}
              </div>
            </div>

            {/* Excel Field Mappings */}
            {config.excelFieldMappings && Object.keys(config.excelFieldMappings).length > 0 && (
              <div>
                <h3 className="font-semibold mb-2">Excel Field Mappings</h3>
                {(() => {
                  const excelOnly = Object.entries(config.excelFieldMappings).filter(([_, m]) => m.dataSource === 'EXCEL');
                  const bothFields = Object.entries(config.excelFieldMappings).filter(([_, m]) => m.dataSource === 'BOTH');

                  return (
                    <div className="space-y-3">
                      {/* Excel Only Fields */}
                      {excelOnly.length > 0 && (
                        <div>
                          <h4 className="text-sm font-medium text-green-700 mb-2">Excel Only Fields</h4>
                          <ul className="text-sm text-gray-700 space-y-1">
                            {excelOnly.map(([fieldKey, mapping]) => (
                              <li key={fieldKey} className="border-l-2 border-green-400 pl-3">
                                <span className="font-medium">{fieldKey}:</span>{' '}
                                <span className="text-gray-600">Excel column "{mapping.excelColumn}"</span>
                              </li>
                            ))}
                          </ul>
                        </div>
                      )}

                      {/* BOTH Fields */}
                      {bothFields.length > 0 && (
                        <div>
                          <h4 className="text-sm font-medium text-purple-700 mb-2">Fields in Both Excel and PDF</h4>
                          <ul className="text-sm text-gray-700 space-y-1">
                            {bothFields.map(([fieldKey, mapping]) => {
                              // Find PDF field name for this field
                              const pdfField = Object.values(config.noteTypeConfigs)
                                .flatMap(nc => Object.entries(nc.fields || {}))
                                .find(([fk]) => fk === fieldKey);
                              
                              return (
                                <li key={fieldKey} className="border-l-2 border-purple-400 pl-3">
                                  <span className="font-medium">{fieldKey}:</span>{' '}
                                  <span className="text-gray-600">
                                    Excel: "{mapping.excelColumn}"
                                    {pdfField && ` • PDF: "${pdfField[1].fieldName}"`}
                                  </span>
                                </li>
                              );
                            })}
                          </ul>
                        </div>
                      )}
                    </div>
                  );
                })()}
              </div>
            )}
          </div>

          <div className="flex space-x-4">
            <button
              onClick={() => setStep('configure')}
              className="px-4 py-2 border rounded-lg text-gray-700 hover:bg-gray-50"
            >
              Back
            </button>
            <button
              onClick={handleSaveConfiguration}
              className="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600"
            >
              {editingConfig ? 'Update Configuration' : 'Save Configuration'}
            </button>
          </div>
        </div>
      )}

      {/* Step: View Saved Configurations */}
      {step === 'saved' && (
        <div className="space-y-6">
          <div className="flex justify-between items-center">
            <div>
              <h2 className="text-xl font-semibold text-gray-900 mb-2">Saved Configurations</h2>
              <p className="text-gray-600 mb-4">
                View and manage your saved onboarding configurations.
              </p>
            </div>
            <button
              onClick={() => setStep('upload')}
              className="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition-colors"
            >
              Back to Upload
            </button>
          </div>

          {loadingConfigs ? (
            <div className="text-center py-12">
              <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-cyan-500 mx-auto"></div>
              <p className="mt-4 text-gray-600">Loading configurations...</p>
            </div>
          ) : savedConfigs.length === 0 ? (
            <div className="border rounded-lg p-12 text-center bg-gray-50">
              <p className="text-gray-600 mb-4">No saved configurations yet.</p>
              <button
                onClick={() => setStep('upload')}
                className="px-4 py-2 bg-cyan-500 text-white rounded-lg hover:bg-cyan-600"
              >
                Create New Configuration
              </button>
            </div>
          ) : (
            <div className="grid gap-4">
              {savedConfigs.map((savedConfig) => (
                <div key={savedConfig.chainId} className="border rounded-lg p-6 bg-white hover:shadow-md transition-shadow">
                  <div className="flex justify-between items-start mb-4">
                    <div>
                      <h3 className="text-lg font-semibold text-gray-900">{savedConfig.chainName}</h3>
                      <p className="text-sm text-gray-500 mt-1">Chain ID: {savedConfig.chainId}</p>
                      {savedConfig.createdAt && (
                        <p className="text-xs text-gray-400 mt-1">
                          Created: {new Date(savedConfig.createdAt).toLocaleDateString()}
                          {savedConfig.updatedAt && savedConfig.updatedAt !== savedConfig.createdAt && (
                            <span> • Updated: {new Date(savedConfig.updatedAt).toLocaleDateString()}</span>
                          )}
                        </p>
                      )}
                    </div>
                    <div className="flex space-x-2">
                      <button
                        onClick={() => handleLoadConfig(savedConfig)}
                        className="px-4 py-2 bg-cyan-500 text-white rounded-lg hover:bg-cyan-600 text-sm"
                      >
                        View Details
                      </button>
                      <button
                        onClick={() => handleEditConfig(savedConfig)}
                        className="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 text-sm"
                      >
                        Edit
                      </button>
                      <button
                        onClick={() => generateRFC(savedConfig)}
                        className="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 text-sm"
                      >
                        Export RFC PDF
                      </button>
                      <button
                        onClick={() => handleDeleteConfig(savedConfig.chainId)}
                        className="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 text-sm"
                      >
                        Delete
                      </button>
                    </div>
                  </div>

                  <div className="grid grid-cols-3 gap-4 mt-4">
                    <div className="bg-yellow-50 rounded p-3">
                      <p className="text-xs text-yellow-700 font-medium mb-1">Behaviour Note Types</p>
                      <p className="text-sm font-semibold text-yellow-900">{savedConfig.behaviourNoteTypes.length}</p>
                    </div>
                    <div className="bg-blue-50 rounded p-3">
                      <p className="text-xs text-blue-700 font-medium mb-1">Follow-up Note Types</p>
                      <p className="text-sm font-semibold text-blue-900">{savedConfig.followUpNoteTypes.length}</p>
                    </div>
                    <div className="bg-green-50 rounded p-3">
                      <p className="text-xs text-green-700 font-medium mb-1">Note Type Configs</p>
                      <p className="text-sm font-semibold text-green-900">{Object.keys(savedConfig.noteTypeConfigs).length}</p>
                    </div>
                  </div>

                  {Object.keys(savedConfig.noteTypeConfigs).length > 0 && (
                    <div className="mt-4 pt-4 border-t">
                      <p className="text-xs text-gray-500 font-medium mb-2">Note Types:</p>
                      <div className="flex flex-wrap gap-2">
                        {Object.keys(savedConfig.noteTypeConfigs).map((noteType) => {
                          const noteConfig = savedConfig.noteTypeConfigs[noteType];
                          const fieldCount = noteConfig?.fields ? Object.keys(noteConfig.fields).length : 0;
                          return (
                            <div
                              key={noteType}
                              className="px-3 py-1 bg-gray-100 rounded text-xs text-gray-700"
                            >
                              {noteConfig?.name || noteType} ({fieldCount} {fieldCount === 1 ? 'field' : 'fields'})
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  )}
                </div>
              ))}
            </div>
          )}
        </div>
      )}

      {/* Config Details Modal */}
      {viewingConfig && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-lg max-w-4xl w-full max-h-[90vh] overflow-y-auto">
            <div className="sticky top-0 bg-white border-b px-6 py-4 flex justify-between items-center">
              <h3 className="text-xl font-semibold text-gray-900">
                Configuration Details: {viewingConfig.chainName}
              </h3>
              <div className="flex items-center space-x-2">
                <button
                  onClick={() => generateRFC(viewingConfig)}
                  className="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 text-sm"
                >
                  Export RFC PDF
                </button>
                <button
                  onClick={handleCloseViewConfig}
                  className="text-gray-400 hover:text-gray-600 text-2xl font-bold"
                >
                  ×
                </button>
              </div>
            </div>
            
            <div className="p-6 space-y-6">
              <div>
                <h4 className="font-semibold mb-2">Chain Information</h4>
                <div className="grid grid-cols-2 gap-4 text-sm">
                  <div>
                    <span className="text-gray-600">Chain ID:</span>{' '}
                    <span className="font-medium">{viewingConfig.chainId}</span>
                  </div>
                  <div>
                    <span className="text-gray-600">Chain Name:</span>{' '}
                    <span className="font-medium">{viewingConfig.chainName}</span>
                  </div>
                </div>
              </div>

              <div>
                <h4 className="font-semibold mb-2">Behaviour Note Types</h4>
                <ul className="list-disc list-inside text-sm text-gray-700 space-y-1">
                  {viewingConfig.behaviourNoteTypes.map((type, i) => (
                    <li key={i}>{type}</li>
                  ))}
                </ul>
              </div>

              <div>
                <h4 className="font-semibold mb-2">Follow-up Note Types</h4>
                <ul className="list-disc list-inside text-sm text-gray-700 space-y-1">
                  {viewingConfig.followUpNoteTypes.map((type, i) => (
                    <li key={i}>{type}</li>
                  ))}
                </ul>
              </div>

              <div>
                <h4 className="font-semibold mb-2">Field Extraction Markers</h4>
                <div className="space-y-3">
                  {Object.entries(viewingConfig.noteTypeConfigs).map(([noteType, noteConfig]) => (
                    <div key={noteType} className="border-l-4 border-cyan-500 pl-4">
                      <h5 className="font-medium text-sm mb-2">{noteConfig?.name || noteType}</h5>
                      {noteConfig?.fields && Object.entries(noteConfig.fields).length > 0 ? (
                        <ul className="text-sm text-gray-700 space-y-1">
                          {Object.entries(noteConfig.fields).map(([fieldKey, fieldConfig]) => (
                            <li key={fieldKey}>
                              <span className="font-medium">{fieldKey}:</span>{' '}
                              <span className="text-gray-600">"{fieldConfig.fieldName}"</span>
                              {fieldConfig.endMarkers && fieldConfig.endMarkers.length > 0 && (
                                <span className="text-gray-500 text-xs ml-2">
                                  (ends at: {fieldConfig.endMarkers.join(', ')})
                                </span>
                              )}
                            </li>
                          ))}
                        </ul>
                      ) : (
                        <p className="text-xs text-gray-500">No fields configured</p>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            </div>

            <div className="sticky bottom-0 bg-gray-50 border-t px-6 py-4 flex justify-end">
              <button
                onClick={handleCloseViewConfig}
                className="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
              >
                Close
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

interface EditConfigurationViewProps {
  config: OnboardingConfig;
  chainId: string;
  chainName: string;
  onChainIdChange: (value: string) => void;
  onChainNameChange: (value: string) => void;
  onSave: (updatedConfig: OnboardingConfig) => void;
  onCancel: () => void;
}

function EditConfigurationView({
  config,
  chainId,
  chainName,
  onChainIdChange,
  onChainNameChange,
  onSave,
  onCancel,
}: EditConfigurationViewProps) {
  const [editedConfig, setEditedConfig] = useState<OnboardingConfig>({ ...config });
  const [editingNoteType, setEditingNoteType] = useState<string | null>(null);
  const [editingField, setEditingField] = useState<{ noteTypeKey: string; fieldKey: string } | null>(null);

  const handleAddNoteType = () => {
    const noteTypeName = prompt('Enter note type name:');
    if (!noteTypeName) return;

    const isFollowUp = confirm('Is this a follow-up note type?');
    const noteTypeKey = `note_${Date.now()}`;

    setEditedConfig(prev => ({
      ...prev,
      noteTypeConfigs: {
        ...prev.noteTypeConfigs,
        [noteTypeKey]: {
          name: noteTypeName,
          isFollowUp,
          fields: {},
        },
      },
      ...(isFollowUp
        ? { followUpNoteTypes: [...prev.followUpNoteTypes, noteTypeName] }
        : { behaviourNoteTypes: [...prev.behaviourNoteTypes, noteTypeName] }),
    }));
  };

  const handleRemoveNoteType = (noteTypeKey: string, noteTypeName: string) => {
    if (!confirm(`Remove note type "${noteTypeName}"?`)) return;

    const noteTypeConfig = editedConfig.noteTypeConfigs[noteTypeKey];
    setEditedConfig(prev => {
      const newConfig = { ...prev };
      delete newConfig.noteTypeConfigs[noteTypeKey];

      if (noteTypeConfig.isFollowUp) {
        newConfig.followUpNoteTypes = prev.followUpNoteTypes.filter(nt => nt !== noteTypeName);
      } else {
        newConfig.behaviourNoteTypes = prev.behaviourNoteTypes.filter(nt => nt !== noteTypeName);
      }

      return newConfig;
    });
  };

  const handleUpdateNoteTypeName = (noteTypeKey: string, oldName: string, newName: string) => {
    if (!newName || newName === oldName) return;

    const noteTypeConfig = editedConfig.noteTypeConfigs[noteTypeKey];
    setEditedConfig(prev => {
      const newConfig = { ...prev };
      newConfig.noteTypeConfigs[noteTypeKey] = {
        ...noteTypeConfig,
        name: newName,
      };

      if (noteTypeConfig.isFollowUp) {
        newConfig.followUpNoteTypes = prev.followUpNoteTypes.map(nt => nt === oldName ? newName : nt);
      } else {
        newConfig.behaviourNoteTypes = prev.behaviourNoteTypes.map(nt => nt === oldName ? newName : nt);
      }

      return newConfig;
    });
  };

  const handleAddField = (noteTypeKey: string) => {
    const fieldKey = prompt('Enter field key (e.g., behaviour_type, interventions):');
    if (!fieldKey) return;

    const fieldName = prompt('Enter field name (as it appears in PDF):');
    if (!fieldName) return;

    setEditedConfig(prev => ({
      ...prev,
      noteTypeConfigs: {
        ...prev.noteTypeConfigs,
        [noteTypeKey]: {
          ...prev.noteTypeConfigs[noteTypeKey],
          fields: {
            ...prev.noteTypeConfigs[noteTypeKey].fields,
            [fieldKey]: {
              fieldName,
              endMarkers: [],
            },
          },
        },
      },
    }));
  };

  const handleRemoveField = (noteTypeKey: string, fieldKey: string) => {
    if (!confirm(`Remove field "${fieldKey}"?`)) return;

    setEditedConfig(prev => {
      const newConfig = { ...prev };
      const fields = { ...newConfig.noteTypeConfigs[noteTypeKey].fields };
      delete fields[fieldKey];
      newConfig.noteTypeConfigs[noteTypeKey] = {
        ...newConfig.noteTypeConfigs[noteTypeKey],
        fields,
      };
      return newConfig;
    });
  };

  const handleUpdateFieldName = (noteTypeKey: string, fieldKey: string, newFieldName: string) => {
    if (!newFieldName) return;

    setEditedConfig(prev => ({
      ...prev,
      noteTypeConfigs: {
        ...prev.noteTypeConfigs,
        [noteTypeKey]: {
          ...prev.noteTypeConfigs[noteTypeKey],
          fields: {
            ...prev.noteTypeConfigs[noteTypeKey].fields,
            [fieldKey]: {
              ...prev.noteTypeConfigs[noteTypeKey].fields[fieldKey],
              fieldName: newFieldName,
            },
          },
        },
      },
    }));
  };

  const handleAddEndMarker = (noteTypeKey: string, fieldKey: string) => {
    const endMarker = prompt('Enter end marker text:');
    if (!endMarker) return;

    setEditedConfig(prev => ({
      ...prev,
      noteTypeConfigs: {
        ...prev.noteTypeConfigs,
        [noteTypeKey]: {
          ...prev.noteTypeConfigs[noteTypeKey],
          fields: {
            ...prev.noteTypeConfigs[noteTypeKey].fields,
            [fieldKey]: {
              ...prev.noteTypeConfigs[noteTypeKey].fields[fieldKey],
              endMarkers: [...prev.noteTypeConfigs[noteTypeKey].fields[fieldKey].endMarkers, endMarker],
            },
          },
        },
      },
    }));
  };

  const handleRemoveEndMarker = (noteTypeKey: string, fieldKey: string, index: number) => {
    setEditedConfig(prev => ({
      ...prev,
      noteTypeConfigs: {
        ...prev.noteTypeConfigs,
        [noteTypeKey]: {
          ...prev.noteTypeConfigs[noteTypeKey],
          fields: {
            ...prev.noteTypeConfigs[noteTypeKey].fields,
            [fieldKey]: {
              ...prev.noteTypeConfigs[noteTypeKey].fields[fieldKey],
              endMarkers: prev.noteTypeConfigs[noteTypeKey].fields[fieldKey].endMarkers.filter((_, i) => i !== index),
            },
          },
        },
      },
    }));
  };

  const handleSave = () => {
    const updatedConfig: OnboardingConfig = {
      ...editedConfig,
      chainId,
      chainName,
    };
    onSave(updatedConfig);
  };

  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-xl font-semibold text-gray-900 mb-2">Edit Chain Configuration</h2>
        <p className="text-gray-600 mb-4">
          Update the chain information and field configurations.
        </p>
      </div>

      <div className="grid grid-cols-2 gap-6">
        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Chain ID *
            </label>
            <input
              type="text"
              value={chainId}
              onChange={(e) => onChainIdChange(e.target.value)}
              className="w-full px-3 py-2 border rounded-lg"
              placeholder="e.g., mill_creek"
            />
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Chain Name *
            </label>
            <input
              type="text"
              value={chainName}
              onChange={(e) => onChainNameChange(e.target.value)}
              className="w-full px-3 py-2 border rounded-lg"
              placeholder="e.g., Mill Creek Care"
            />
          </div>
        </div>

        <div className="border rounded-lg p-4">
          <h3 className="font-semibold mb-3">Configuration Summary</h3>
          <div className="space-y-2 text-sm">
            <div>
              <span className="font-medium">Behaviour Note Types:</span>{' '}
              {editedConfig.behaviourNoteTypes.length}
            </div>
            <div>
              <span className="font-medium">Follow-up Note Types:</span>{' '}
              {editedConfig.followUpNoteTypes.length}
            </div>
            <div>
              <span className="font-medium">Total Note Types:</span>{' '}
              {Object.keys(editedConfig.noteTypeConfigs).length}
            </div>
            <div>
              <span className="font-medium">Total Fields:</span>{' '}
              {Object.values(editedConfig.noteTypeConfigs).reduce(
                (sum, config) => sum + Object.keys(config.fields).length,
                0
              )}
            </div>
          </div>
        </div>
      </div>

      <div className="border rounded-lg p-6 bg-white">
        <div className="flex justify-between items-center mb-4">
          <h3 className="text-lg font-semibold text-gray-900">Note Types & Fields</h3>
          <button
            onClick={handleAddNoteType}
            className="px-3 py-1.5 text-sm bg-cyan-500 text-white rounded hover:bg-cyan-600"
          >
            + Add Note Type
          </button>
        </div>

        <div className="space-y-6">
          {Object.entries(editedConfig.noteTypeConfigs).map(([noteTypeKey, noteTypeConfig]) => (
            <div key={noteTypeKey} className="border rounded-lg p-4 bg-gray-50">
              <div className="flex items-center justify-between mb-3">
                <div className="flex items-center space-x-3">
                  <input
                    type="text"
                    value={noteTypeConfig.name}
                    onChange={(e) => handleUpdateNoteTypeName(noteTypeKey, noteTypeConfig.name, e.target.value)}
                    className="px-3 py-1.5 border rounded-lg font-semibold bg-white"
                  />
                  <span className={`px-2 py-1 rounded text-xs font-medium ${
                    noteTypeConfig.isFollowUp
                      ? 'bg-purple-100 text-purple-800'
                      : 'bg-blue-100 text-blue-800'
                  }`}>
                    {noteTypeConfig.isFollowUp ? 'Follow-up' : 'Behaviour'}
                  </span>
                </div>
                <div className="flex items-center space-x-2">
                  <button
                    onClick={() => handleAddField(noteTypeKey)}
                    className="px-2 py-1 text-xs bg-green-500 text-white rounded hover:bg-green-600"
                  >
                    + Add Field
                  </button>
                  <button
                    onClick={() => handleRemoveNoteType(noteTypeKey, noteTypeConfig.name)}
                    className="px-2 py-1 text-xs bg-red-500 text-white rounded hover:bg-red-600"
                  >
                    Remove
                  </button>
                </div>
              </div>

              <div className="ml-4 space-y-3 mt-3">
                {Object.entries(noteTypeConfig.fields).map(([fieldKey, fieldConfig]) => (
                  <div key={fieldKey} className="bg-white border rounded-lg p-3">
                    <div className="flex items-center justify-between mb-2">
                      <div className="flex items-center space-x-2">
                        <span className="font-medium text-sm text-gray-700">{fieldKey}</span>
                        <input
                          type="text"
                          value={fieldConfig.fieldName}
                          onChange={(e) => handleUpdateFieldName(noteTypeKey, fieldKey, e.target.value)}
                          className="px-2 py-1 text-sm border rounded flex-1 max-w-xs"
                          placeholder="Field name in PDF"
                        />
                      </div>
                      <button
                        onClick={() => handleRemoveField(noteTypeKey, fieldKey)}
                        className="px-2 py-1 text-xs bg-red-500 text-white rounded hover:bg-red-600"
                      >
                        Remove
                      </button>
                    </div>

                    <div className="ml-4 mt-2">
                      <div className="flex items-center justify-between mb-1">
                        <span className="text-xs text-gray-600">End Markers:</span>
                        <button
                          onClick={() => handleAddEndMarker(noteTypeKey, fieldKey)}
                          className="px-2 py-0.5 text-xs bg-gray-500 text-white rounded hover:bg-gray-600"
                        >
                          + Add
                        </button>
                      </div>
                      {fieldConfig.endMarkers.length > 0 ? (
                        <div className="space-y-1">
                          {fieldConfig.endMarkers.map((marker, index) => (
                            <div key={index} className="flex items-center space-x-2">
                              <span className="text-xs px-2 py-1 bg-gray-100 rounded">{marker}</span>
                              <button
                                onClick={() => handleRemoveEndMarker(noteTypeKey, fieldKey, index)}
                                className="text-xs text-red-600 hover:text-red-800"
                              >
                                ×
                              </button>
                            </div>
                          ))}
                        </div>
                      ) : (
                        <p className="text-xs text-gray-400 italic">No end markers</p>
                      )}
                    </div>
                  </div>
                ))}
                {Object.keys(noteTypeConfig.fields).length === 0 && (
                  <p className="text-sm text-gray-400 italic ml-4">No fields configured</p>
                )}
              </div>
            </div>
          ))}

          {Object.keys(editedConfig.noteTypeConfigs).length === 0 && (
            <p className="text-center text-gray-400 py-8">No note types configured. Add one to get started.</p>
          )}
        </div>
      </div>

      <div className="flex space-x-4">
        <button
          onClick={onCancel}
          className="px-4 py-2 border rounded-lg text-gray-700 hover:bg-gray-50"
        >
          Cancel
        </button>
        <button
          onClick={handleSave}
          disabled={!chainId || !chainName}
          className="px-4 py-2 bg-cyan-500 text-white rounded-lg hover:bg-cyan-600 disabled:bg-gray-300 disabled:cursor-not-allowed"
        >
          Save Changes & Review
        </button>
      </div>
    </div>
  );
}

interface LabelDialogProps {
  highlight: Partial<Highlight>;
  existingHighlights: Highlight[];
  onSave: (label: string, labelType: Highlight['labelType'], noteType?: string, fieldKey?: string) => void;
  onCancel: () => void;
}

function LabelDialog({ highlight, existingHighlights, onSave, onCancel }: LabelDialogProps) {
  const [label, setLabel] = useState('');
  const [labelType, setLabelType] = useState<Highlight['labelType']>('field-name');
  const [noteType, setNoteType] = useState<string>('');
  const [fieldKey, setFieldKey] = useState<string>('');

  const noteTypes = existingHighlights
    .filter(h => h.labelType === 'note-type')
    .map(h => h.label);

  const handleSave = () => {
    if (!label.trim()) {
      alert('Please enter a label');
      return;
    }

    if (labelType === 'field-name' && !noteType) {
      alert('Please select a note type for this field');
      return;
    }

    onSave(label, labelType, noteType || undefined, fieldKey || undefined);
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 max-w-md w-full">
        <h3 className="text-lg font-semibold mb-4">Label Selection</h3>
        
        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Selected Text
            </label>
            <p className="text-sm text-gray-600 bg-gray-50 p-2 rounded">
              {highlight.text?.substring(0, 200)}
              {highlight.text && highlight.text.length > 200 && '...'}
            </p>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Label Type *
            </label>
            <select
              value={labelType}
              onChange={(e) => setLabelType(e.target.value as Highlight['labelType'])}
              className="w-full px-3 py-2 border rounded-lg"
            >
              <option value="note-type">Note Type</option>
              <option value="field-name">Field Name</option>
              <option value="end-marker">End Marker</option>
              <option value="other">Other</option>
            </select>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Label *
            </label>
            <input
              type="text"
              value={label}
              onChange={(e) => setLabel(e.target.value)}
              className="w-full px-3 py-2 border rounded-lg"
              placeholder="Enter label for this selection"
            />
          </div>

          {labelType === 'field-name' && (
            <>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Note Type *
                </label>
                <select
                  value={noteType}
                  onChange={(e) => setNoteType(e.target.value)}
                  className="w-full px-3 py-2 border rounded-lg"
                >
                  <option value="">Select note type...</option>
                  {noteTypes.map((nt) => (
                    <option key={nt} value={nt}>{nt}</option>
                  ))}
                </select>
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Field Key (optional)
                </label>
                <input
                  type="text"
                  value={fieldKey}
                  onChange={(e) => setFieldKey(e.target.value)}
                  className="w-full px-3 py-2 border rounded-lg"
                  placeholder="e.g., behaviour_type, interventions"
                />
                <p className="text-xs text-gray-500 mt-1">
                  Leave empty to auto-generate from label
                </p>
              </div>
            </>
          )}

          {labelType === 'end-marker' && (
            <>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Note Type
                </label>
                <select
                  value={noteType}
                  onChange={(e) => setNoteType(e.target.value)}
                  className="w-full px-3 py-2 border rounded-lg"
                >
                  <option value="">All note types</option>
                  {noteTypes.map((nt) => (
                    <option key={nt} value={nt}>{nt}</option>
                  ))}
                </select>
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Field Key (optional)
                </label>
                <input
                  type="text"
                  value={fieldKey}
                  onChange={(e) => setFieldKey(e.target.value)}
                  className="w-full px-3 py-2 border rounded-lg"
                  placeholder="e.g., behaviour_type, interventions"
                />
                <p className="text-xs text-gray-500 mt-1">
                  Leave empty to apply to all fields
                </p>
              </div>
            </>
          )}
        </div>

        <div className="flex space-x-4 mt-6">
          <button
            onClick={onCancel}
            className="flex-1 px-4 py-2 border rounded-lg text-gray-700 hover:bg-gray-50"
          >
            Cancel
          </button>
          <button
            onClick={handleSave}
            className="flex-1 px-4 py-2 bg-cyan-500 text-white rounded-lg hover:bg-cyan-600"
          >
            Save
          </button>
        </div>
      </div>
    </div>
  );
}

